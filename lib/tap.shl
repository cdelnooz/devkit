#!/bin/sh
#
# TAP.SHL --Test-Anything-Protocol functions.
#
# Contents:
# caller()          --Fake implementation of bash's caller().
# tty_filter()      --Filter stdout suitably/conditionally for a tty.
# diag()            --Print diagnostic lines as TAP comments.
# TAP_BEGIN()       --Startup code for the TAP module, print TAP prologue.
# TAP_EXIT()        --Write some summary diagnostics as TAP epilogue.
# plan()            --Declare the number of tests.
# todo()            --Mark the start/end of a "todo" block.
# tap_test_msg()    --Common function to report on tests.
# tap_report_diff() --Report differences between two strings.
# ok()              --Check a process result, and emit TAP output.
# nok()             --Check a process result, and emit TAP output.
# ok_eq()           --compare two strings for equality, report differences.
# nok_eq()          --compare two strings for inequality, report differences.
# ok_match()        --Compare a string to a glob-pattern, report differences.
# nok_match()       --Compare a string to a glob-pattern, report differences.
# ok_grep()         --Compare a string to a regex pattern, report differences.
# nok_grep()        --Compare a string to a regex pattern, report differences.
#
# Remarks:
# This library is an implementation Perl's TAP system for shell scripts.
# TODO: skip
#
version=local.latest
export isatty=
tap_test=0
tap_todo_reason=
tap_plan=0
tap_fail=0
tap_version="${version}"

export ok_style=''			# plain
export fail_style='1;31'		# bold+red
export log_style='1'			# bold
export diag_style='36'			# cyan

if [ -t 1 ]; then
    isatty=1
fi

#
# caller() --Fake implementation of bash's caller().
#
if ! type caller >/dev/null; then
    caller() { printf '(unknown) unknown (input)\n'; }
fi
# TODO: better trap handling for tap.
if ! type tap_exit >/dev/null; then
    tap_exit() {:;}
fi

#
# tty_filter() --Filter stdout suitably/conditionally for a tty.
#
# Parameters:
# style	--the preferred output styling, as an ANSI mode arg (e.g. "1;33")
#
tty_filter()
{
    local style=$1; shift

    if [ "$isatty" ]; then
        while read line; do
            printf "\033[%sm%s\033[m\n" "$style" "$line"
        done
    else
        cat
    fi
}

#
# diag() --Print diagnostic lines as TAP comments.
#
# Remarks:
# If any arguments are provided, they are passed on to printf,
# and that's what gets output.  If there are no arguments, cat
# is used to passthrough the lines of text.
#
diag()
{
    if [ $# -gt 0 ]; then
        printf "$@"
	printf "\n"
    else
	cat
    fi | sed -e "s/^/# "/ | tty_filter "$diag_style"
}

#
# TAP_BEGIN() --Startup code for the TAP module, print TAP prologue.
#
TAP_BEGIN()
{
    diag 'current time local: %s' "$(date)"
    diag 'current time UTC:   %s' "$(TZ=UTC date)"
    diag 'tap.shl version:    %s' "$tap_version"
    trap TAP_EXIT 0
}
TAP_BEGIN

#
# TAP_EXIT() --Write a test summary as TAP epilogue, and set exit status.
#
TAP_EXIT()
{
    local s=			# plural-suffix
    local status=

    tap_exit
    if [ $tap_test -ne $tap_plan ]; then
	s=; test $tap_plan -ne 1 && s=s
	diag "Looks like you planned %d test%s but ran %d." \
	    "$tap_plan" "$s"  "$tap_test"
	status=2
    fi
    if [ $tap_fail -ne 0 ]; then
	s=; test $tap_fail -gt 1 && s=s
	diag "Looks like you failed %d test%s of %d run." \
	"$tap_fail" "$s" "$tap_test"
	status=${status:-1}
    fi
    exit ${status:-0}
}

#
# plan() --Declare the number of tests.
#
plan()
{
    if [ $# -ne 0 ]; then
	tap_plan=$1
    else
	tap_plan=$tap_test
    fi
    echo "1..$tap_plan" | tty_filter "$log_style"
}

#
# todo() --Mark the start/end of a "todo" block.
#
todo()
{
    tap_todo_reason="$1"; shift
}

#
# tap_test_msg() --Common function to report on tests.
#
tap_test_msg()
{
    local result=$1; shift
    local msg=
    local status=ok
    local style=$ok_style

    tap_test=$(( $tap_test + 1))

    if [ $# -gt 0 ]; then
	if [ $# -gt 1 ]; then
	    msg=$(printf "$@")
	else
	    msg=$1
	fi
	msg=" - $msg"
    fi
    if [ "$tap_todo_reason" ]; then
	msg="$msg  # TODO $tap_todo_reason"
    fi

    if [ $result -ne 0 ]; then
	status="not ok"
        style=$fail_style
	if [ ! "$tap_todo_reason" ]; then
	    tap_fail=$(( $tap_fail + 1))
	fi
    fi
    printf '%s %d%s\n' "$status" $tap_test "$msg" | tty_filter "$style"
    if [ $result -ne 0 ]; then
	local file=$(caller 1 | cut -d' ' -f3 | sed -e 's/^NULL$/(input)/')
	local line=$(caller 1 | cut -d' ' -f1)

	diag '   Failed test %s' "$tap_test"
	diag '   in "%s" at line %s' "${file:-stdin}" "$line"
    fi
    return $result
}

#
# tap_report_diff() --Report differences between two strings.
#
tap_report_diff()
{
    diag "%12s: '%s'" 'got' "$1"
    diag "%12s: '%s'" 'expected' "$2"
    false
}


#
# ok() --Check a process result, and emit TAP output.
#
ok()
{
    tap_test_msg "$@"
}

#
# nok() --Check a process result, and emit TAP output.
#
nok()
{
   local tap_status=$1; shift

   if [ $tap_status -eq 0 ]; then
       tap_status=1;
   else
       tap_status=0;
   fi
   tap_test_msg $tap_status "$@"
}

#
# ok_eq() --compare two strings for equality, report differences.
#
ok_eq()
{
    local have="$1"; shift
    local expect="$1"; shift

    test "$have" = "$expect";
    tap_test_msg $? "$@" || tap_report_diff "$have" "$expect"
}

#
# nok_eq() --compare two strings for inequality, report differences.
#
# Remarks:
# differences?
#
nok_eq()
{
    local have="$1"; shift
    local expect="$1"; shift

    test "$have" != "$expect";
    tap_test_msg $? "$@" || tap_report_diff "$have" "$expect"
}

#
# ok_match() --Compare a string to a glob-pattern, report differences.
#
ok_match()
{
    local have="$1"; shift
    local expect="$1"; shift

    case "$have" in
    $expect) true;;
    *) false;;
    esac
    tap_test_msg $? "$@" ||
	tap_report_diff "$have" "a glob matching  \"$expect\""
}

#
# nok_match() --Compare a string to a glob-pattern, report differences.
#
nok_match()
{
    local have="$1"; shift
    local expect="$1"; shift

    case "$have" in
    $expect) false;;
    *) true;;
    esac
    tap_test_msg $? "$@" ||
	tap_report_diff "$have" "a glob matching  \"$expect\""
}

#
# ok_grep() --Compare a string to a regex pattern, report differences.
#
ok_grep()
{
    local have="$1"; shift
    local expect="$1"; shift

    echo "$have" | grep -q -- "$expect"
    tap_test_msg $? "$@" ||
	tap_report_diff "$have" "a regex matching \"$expect\""
}

#
# nok_grep() --Compare a string to a regex pattern, report differences.
#
nok_grep()
{
    local have="$1"; shift
    local expect="$1"; shift

    echo "$have" | grep -q -- "$expect"
    test $? -ne 0
    tap_test_msg $? "$@" ||
	tap_report_diff "$have" "a regex not matching \"$expect\""
}
