#!/bin/sh
#
# TAP.SHL --Test-Anything-Protocol functions.
#
# Remarks:
# This library is an implementation Perl's TAP system for shell scripts.
# TODO: skip
#
# Contents:
# caller()          --Fake implementation of bash's caller().
# tty_filter()      --Filter stdout suitably/conditionally for a tty.
# diag()            --Print diagnostic lines as TAP comments.
# TAP_BEGIN()       --Startup code for the TAP module, print TAP prologue.
# TAP_EXIT()        --Write a test summary as TAP epilogue, and set exit status.
# plan()            --Declare the number of tests.
# todo()            --Mark the start/end of a "todo" block.
# tap_test_msg()    --Common function to report on tests.
# tap_report_diff() --Report differences between two strings.
# ok()              --Check a process result, and emit TAP output.
# nok()             --Check a process result, and emit TAP output.
#
. test-more.shl
version=local.latest
export isatty=
tap_test=0
tap_todo_reason=
tap_plan=0
tap_fail=0
tap_version="${version}"

export ok_style=			# plain
export fail_style='1;31'		# bold+red
export log_style='1'			# bold
export diag_style='36'			# cyan

if [ -t 1 ]; then
    isatty=1
fi

#
# caller() --Fake implementation of bash's caller().
#
if ! type caller >/dev/null; then
    caller() { printf '(unknown) unknown (input)\n'; }
fi
# TODO: better trap handling for tap.
if ! type tap_exit >/dev/null 2>&1; then
    tap_exit() { :; }
fi

#
# tty_filter() --Filter stdout suitably/conditionally for a tty.
#
# Parameters:
# style	--the preferred output styling, as an ANSI mode arg (e.g. "1;33")
#
tty_filter()
{
    local style=$1; shift

    if [ "$isatty" ]; then
        while read line; do
            printf "\033[%sm%s\033[m\n" "$style" "$line"
        done
    else
        cat
    fi
}

#
# diag() --Print diagnostic lines as TAP comments.
#
# Remarks:
# If any arguments are provided, they are passed on to printf,
# and that's what gets output.  If there are no arguments, cat
# is used to passthrough the lines of text.
#
diag()
{
    if [ $# -gt 0 ]; then
        printf "$@"
	printf "\n"
    else
	cat
    fi | sed -e "s/^/# "/ | tty_filter "$diag_style"
}

#
# TAP_BEGIN() --Startup code for the TAP module, print TAP prologue.
#
TAP_BEGIN()
{
    diag 'current time local: %s' "$(date)"
    diag 'current time UTC:   %s' "$(TZ=UTC date)"
    diag 'tap.shl version:    %s' "$tap_version"
    trap TAP_EXIT 0
}
TAP_BEGIN

#
# TAP_EXIT() --Write a test summary as TAP epilogue, and set exit status.
#
TAP_EXIT()
{
    local s=			# plural-suffix
    local status=

    tap_exit
    if [ $tap_test -ne $tap_plan ]; then
	s=; test $tap_plan -ne 1 && s=s
	diag "Looks like you planned %d test%s but ran %d." \
	    "$tap_plan" "$s"  "$tap_test"
	status=2
    fi
    if [ $tap_fail -ne 0 ]; then
	s=; test $tap_fail -gt 1 && s=s
	diag "Looks like you failed %d test%s of %d run." \
	"$tap_fail" "$s" "$tap_test"
	status=${status:-1}
    fi
    exit ${status:-0}
}

#
# plan() --Declare the number of tests.
#
plan()
{
    if [ $# -ne 0 ]; then
	tap_plan=$1
    else
	tap_plan=$tap_test
    fi
    echo "1..$tap_plan" | tty_filter "$log_style"
}

#
# todo() --Mark the start/end of a "todo" block.
#
# Remarks:
# This function can be used in two ways: as a delimited block, or
# as a command modifier (like nice, nohup etc.). e.g.:
#
#     todo "not implemented yet"
#     ok 1 "some test"
#     todo
#
#     todo "not implemented yet" ok 1 "some test"
#
todo()
{
    case "$#" in
	(0)
	    tap_todo_reason="$1"
	    ;;
	(1)
	    tap_todo_reason="$1"
	    ;;
	(*)
	    local tap_todo_reason="$1"; shift
	    "$@"
	    ;;
    esac
}

#
# tap_test_msg() --Common function to report on tests.
#
# Parameters:
# result	--the test result (0: success, other: failure)
# ...		--printf arg.s
#
tap_test_msg()
{
    local result=$1; shift
    local type=
    local msg=
    local msg_suffix=
    local caller_level=${caller_level:-1}
    local status=ok
    local style=$ok_style
    tap_test=$(( $tap_test + 1))

    if [ $# -gt 0 ]; then
	if [ $# -gt 1 ]; then
	    msg=$(printf "$@")
	else
	    msg=$1
	fi
	msg=" - $msg"
    fi
    if [ "$tap_todo_reason" ]; then
	type=" (TODO)"
	msg_suffix=" # TODO $tap_todo_reason"
	caller_level=$(($caller_level+1))
    fi

    if [ $result -ne 0 ]; then
	status="not ok"
	if [ ! "$tap_todo_reason" ]; then
            style=$fail_style
	fi
	if [ ! "$tap_todo_reason" ]; then
	    tap_fail=$(( $tap_fail + 1))
	fi
    fi
    printf '%s %d%s%s\n' "$status" $tap_test "$msg" "$msg_suffix" | tty_filter "$style"
    if [ $result -ne 0 ]; then
	local file=$(caller $caller_level | cut -d' ' -f3 | sed -e 's/^NULL$/(input)/')
	local line=$(caller $caller_level | cut -d' ' -f1)

	diag '   Failed%s test%s' "$type" "$msg"
	diag '   in %s at line %s' "${file:-stdin}" "${line:-unknown}"
    fi
    return $result
}

#
# tap_report_diff() --Report differences between two strings.
#
tap_report_diff()
{
    diag "%12s: '%s'" 'got' "$1"
    diag "%12s: '%s'" 'expected' "$2"
    false
}

#
# ok() --Check a process result, and emit TAP output.
#
ok() { tap_test_msg "$@"; }

#
# nok() --Check a process result, and emit TAP output.
#
nok()
{
   local tap_status=$1; shift

   if [ $tap_status -eq 0 ]; then
       tap_status=1;
   else
       tap_status=0;
   fi
   tap_test_msg $tap_status "$@"
}
